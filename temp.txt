// agent.cpp â€” FINAL READY-TO-USE VERSION (Includes Dynamic ID, Full Control, and Key Mapping)

#include <winsock2.h>
#include <windows.h>
#include <gdiplus.h>
#include <iostream>
#include <vector>
#include <thread>
#include <string>
#include <sstream>
#include <map>
#include <cmath>
#include "json.hpp" // Ensure json.hpp is in the same folder!

#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "Gdiplus.lib")

using namespace Gdiplus;
using json = nlohmann::json;

// ================= GLOBAL VARIABLES & UTILS =================
SOCKET sockGlobal;
bool isConnected = false;
std::string targetViewerId = ""; 
std::string agentUserId = ""; 

// Screen Metrics (Assuming the Sharer's screen size for accurate mouse control scaling)
int screenWidth = GetSystemMetrics(SM_CXSCREEN);
int screenHeight = GetSystemMetrics(SM_CYSCREEN);

// Viewer's Virtual Screen Resolution (Used for inverse scaling)
const int VIEWER_VIRTUAL_WIDTH = 1920; 
const int VIEWER_VIRTUAL_HEIGHT = 1080;


// ================= ID PARSING FUNCTION =================

std::string get_user_id_from_url(const std::string& url) {
Â  Â  size_t start_pos = url.find("user_id=");
Â  Â  if (start_pos == std::string::npos) {
Â  Â  Â  Â  return ""; 
Â  Â  }
Â  Â  start_pos += 8; // Length of "user_id="
Â  Â  
Â  Â  size_t end_pos = url.find('&', start_pos);
Â  Â  if (end_pos == std::string::npos) {
Â  Â  Â  Â  end_pos = url.length();
Â  Â  }
Â  Â  
Â  Â  std::string userId = url.substr(start_pos, end_pos - start_pos);
Â  Â  // Clean up trailing quotes if present
Â  Â  if (!userId.empty() && userId.back() == '"') {
Â  Â  Â  Â  userId.pop_back();
Â  Â  }
Â  Â  return userId;
}

// ================= BASE64 / JPEG ENCODER =================

std::string base64_encode(const unsigned char* data, int len) {
Â  Â  static const char tbl[] =
Â  Â  Â  Â  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
Â  Â  std::string out;
Â  Â  int val = 0, valb = -6;
Â  Â  for (int i = 0; i < len; i++) {
Â  Â  Â  Â  val = (val << 8) + data[i];
Â  Â  Â  Â  valb += 8;
Â  Â  Â  Â  while (valb >= 0) {
Â  Â  Â  Â  Â  Â  out.push_back(tbl[(val >> valb) & 63]);
Â  Â  Â  Â  Â  Â  valb -= 6;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  if (valb > -6) out.push_back(tbl[((val << 8) >> (valb + 8)) & 63]);
Â  Â  while (out.size() % 4) out.push_back('=');
Â  Â  return out;
}

std::string random_key() {
Â  Â  unsigned char temp[16];
Â  Â  for (int i = 0; i < 16; i++) temp[i] = rand() % 255;
Â  Â  return base64_encode(temp, 16);
}

CLSID jpegClsid;

void init_jpeg() {
Â  Â  UINT num, size;
Â  Â  GetImageEncodersSize(&num, &size);
Â  Â  auto* info = (ImageCodecInfo*)malloc(size);
Â  Â  GetImageEncoders(num, size, info);
Â  Â  for (UINT i = 0; i < num; i++) {
Â  Â  Â  Â  if (wcscmp(info[i].MimeType, L"image/jpeg") == 0) {
Â  Â  Â  Â  Â  Â  jpegClsid = info[i].Clsid;
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  free(info);
}

bool capture_screen(std::vector<unsigned char>& out) {
Â  Â  HDC hScreen = GetDC(NULL);
Â  Â  HDC hDC = CreateCompatibleDC(hScreen);
Â  Â  HBITMAP hBitmap = CreateCompatibleBitmap(hScreen, screenWidth, screenHeight);
Â  Â  SelectObject(hDC, hBitmap);

Â  Â  BitBlt(hDC, 0, 0, screenWidth, screenHeight, hScreen, 0, 0, SRCCOPY);

Â  Â  IStream* stream;
Â  Â  CreateStreamOnHGlobal(NULL, TRUE, &stream);

Â  Â  EncoderParameters ep{};
Â  Â  ep.Count = 1;
Â  Â  ep.Parameter[0].Guid = EncoderQuality;
Â  Â  ep.Parameter[0].Type = EncoderParameterValueTypeLong;
Â  Â  ep.Parameter[0].NumberOfValues = 1;
Â  Â  ULONG quality = 50; // Set JPEG quality (adjust as needed, 50 is a balance)
Â  Â  ep.Parameter[0].Value = &quality;

Â  Â  Bitmap bmp(hBitmap, NULL);
Â  Â  bmp.Save(stream, &jpegClsid, &ep);

Â  Â  HGLOBAL hMem;
Â  Â  GetHGlobalFromStream(stream, &hMem);
Â  Â  SIZE_T size = GlobalSize(hMem);
Â  Â  void* data = GlobalLock(hMem);

Â  Â  out.assign((unsigned char*)data, (unsigned char*)data + size);

Â  Â  GlobalUnlock(hMem);
Â  Â  stream->Release();
Â  Â  DeleteObject(hBitmap);
Â  Â  DeleteDC(hDC);
Â  Â  ReleaseDC(NULL, hScreen);

Â  Â  return true;
}

// ================= WS/SOCKET.IO SEND FRAME =================

void send_ws_text(const std::string& data) {
Â  Â  std::vector<unsigned char> frame;
Â  Â  frame.push_back(0x81); 

Â  Â  size_t len = data.size();
Â  Â  unsigned char mask[4];
Â  Â  for (int i = 0; i < 4; i++) mask[i] = rand() % 256;

Â  Â  if (len <= 125) {
Â  Â  Â  Â  frame.push_back(0x80 | len);
Â  Â  } else if (len <= 65535) {
Â  Â  Â  Â  frame.push_back(0x80 | 126);
Â  Â  Â  Â  frame.push_back((len >> 8) & 0xFF);
Â  Â  Â  Â  frame.push_back(len & 0xFF);
Â  Â  } else {
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  frame.insert(frame.end(), mask, mask + 4);
Â  Â  
Â  Â  for (size_t i = 0; i < len; i++)
Â  Â  Â  Â  frame.push_back(data[i] ^ mask[i % 4]);

Â  Â  send(sockGlobal, (char*)frame.data(), frame.size(), 0);
}

// ================= SOCKET.IO SPECIFIC SENDERS =================

void send_socketio_event(const std::string& eventName, const std::string& payloadJson) {
Â  Â  std::string socketio_frame = "42[\"" + eventName + "\"," + payloadJson + "]";
Â  Â  send_ws_text(socketio_frame);
}

void send_online_signal() {
Â  Â  
Â  Â  std::string payload = 
Â  Â  Â  Â  R"({"userId":")" + agentUserId + R"(", "name":"Agent Sharer"})";
Â  Â  send_socketio_event("user-online", payload);
Â  Â  std::cout << "âœ… Sent user-online signal for User ID: " << agentUserId << "\n";
}

void send_screen_update(const std::string& base64_data) {
Â  Â  // Only send if we know who the viewer is
Â  Â  if (targetViewerId.empty()) return; 

Â  Â  std::string img_src = "data:image/jpeg;base64," + base64_data;
Â  Â  
Â  Â  std::string payload = 
Â  Â  Â  Â  R"({"senderId":")" + agentUserId + R"(", "targetId":")" + targetViewerId + R"(", "image":")" + img_src + R"("})";

Â  Â  send_socketio_event("screen-update", payload);
}

// ================= WEBSOCKET/SOCKET.IO CONNECT =================
bool websocket_connect() {
Â  Â  const int PORT = 4000; 
Â  Â  
Â  Â  WSADATA wsa;
Â  Â  if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
        std::cerr << "WSAStartup failed.\n";
        return false;
    }

Â  Â  sockGlobal = socket(AF_INET, SOCK_STREAM, 0);
    if (sockGlobal == INVALID_SOCKET) {
        std::cerr << "Socket creation failed.\n";
        WSACleanup();
        return false;
    }


Â  Â  sockaddr_in addr{};
Â  Â  addr.sin_family = AF_INET;
Â  Â  addr.sin_port = htons(PORT);
Â  Â  addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // Assuming localhost

Â  Â  if (connect(sockGlobal, (sockaddr*)&addr, sizeof(addr)) != 0) {
Â  Â  Â  Â  std::cout << "âŒ TCP connect failed\n";
        closesocket(sockGlobal);
        WSACleanup();
Â  Â  Â  Â  return false;
Â  Â  }

Â  Â  std::string key = random_key();
Â  Â  
Â  Â  std::string req =
Â  Â  Â  Â  "GET /socket.io/?EIO=3&transport=websocket HTTP/1.1\r\n" 
Â  Â  Â  Â  "Host: localhost:" + std::to_string(PORT) + "\r\n"
Â  Â  Â  Â  "Upgrade: websocket\r\n"
Â  Â  Â  Â  "Connection: Upgrade\r\n"
Â  Â  Â  Â  "Sec-WebSocket-Key: " + key + "\r\n"
Â  Â  Â  Â  "Sec-WebSocket-Version: 13\r\n\r\n";

Â  Â  send(sockGlobal, req.c_str(), req.size(), 0);

Â  Â  char buf[2048];
Â  Â  int r = recv(sockGlobal, buf, sizeof(buf), 0);
Â  Â  if (r <= 0 || std::string(buf).find("101") == std::string::npos) {
Â  Â  Â  Â  std::cout << "âŒ WS handshake failed\n";
        closesocket(sockGlobal);
        WSACleanup();
Â  Â  Â  Â  return false;
Â  Â  }
Â  Â  
Â  Â  std::cout << "âœ… WS Handshake successful\n";
Â  Â  isConnected = true;
Â  Â  return true;
}


// ================= KEYBOARD CONTROL LOGIC (FIXED/COMPLETE) =================

UCHAR map_js_code_to_vk(const std::string& jsCode) {
Â  Â  // Static map ensures it is initialized only once (efficient)
Â  Â  static const std::map<std::string, UCHAR> keyMap = {
Â  Â  Â  Â  // Letters
Â  Â  Â  Â  {"KeyA", 0x41}, {"KeyB", 0x42}, {"KeyC", 0x43}, {"KeyD", 0x44}, {"KeyE", 0x45}, {"KeyF", 0x46},
Â  Â  Â  Â  {"KeyG", 0x47}, {"KeyH", 0x48}, {"KeyI", 0x49}, {"KeyJ", 0x4A}, {"KeyK", 0x4B}, {"KeyL", 0x4C},
Â  Â  Â  Â  {"KeyM", 0x4D}, {"KeyN", 0x4E}, {"KeyO", 0x4F}, {"KeyP", 0x50}, {"KeyQ", 0x51}, {"KeyR", 0x52},
Â  Â  Â  Â  {"KeyS", 0x53}, {"KeyT", 0x54}, {"KeyU", 0x55}, {"KeyV", 0x56}, {"KeyW", 0x57}, {"KeyX", 0x58},
Â  Â  Â  Â  {"KeyY", 0x59}, {"KeyZ", 0x5A},

Â  Â  Â  Â  // Numbers (Non-Numpad)
Â  Â  Â  Â  {"Digit0", 0x30}, {"Digit1", 0x31}, {"Digit2", 0x32}, {"Digit3", 0x33}, {"Digit4", 0x34}, 
Â  Â  Â  Â  {"Digit5", 0x35}, {"Digit6", 0x36}, {"Digit7", 0x37}, {"Digit8", 0x38}, {"Digit9", 0x39},

Â  Â  Â  Â  // Function Keys
Â  Â  Â  Â  {"F1", VK_F1}, {"F2", VK_F2}, {"F3", VK_F3}, {"F4", VK_F4}, {"F5", VK_F5}, {"F6", VK_F6},
Â  Â  Â  Â  {"F7", VK_F7}, {"F8", VK_F8}, {"F9", VK_F9}, {"F10", VK_F10}, {"F11", VK_F11}, {"F12", VK_F12},

Â  Â  Â  Â  // Modifiers and Special Keys
Â  Â  Â  Â  {"Space", VK_SPACE}, 
Â  Â  Â  Â  {"Enter", VK_RETURN},
Â  Â  Â  Â  {"Backspace", VK_BACK},
Â  Â  Â  Â  {"Tab", VK_TAB},
Â  Â  Â  Â  {"Escape", VK_ESCAPE},
Â  Â  Â  Â  {"Delete", VK_DELETE},
Â  Â  Â  Â  {"Insert", VK_INSERT},

Â  Â  Â  Â  // Control Keys
Â  Â  Â  Â  {"ControlLeft", VK_LCONTROL}, {"ControlRight", VK_RCONTROL},
Â  Â  Â  Â  {"ShiftLeft", VK_LSHIFT}, {"ShiftRight", VK_RSHIFT},
Â  Â  Â  Â  {"AltLeft", VK_LMENU}, {"AltRight", VK_RMENU},

Â  Â  Â  Â  // Arrows
Â  Â  Â  Â  {"ArrowUp", VK_UP}, {"ArrowDown", VK_DOWN}, {"ArrowLeft", VK_LEFT}, {"ArrowRight", VK_RIGHT},

Â  Â  Â  Â  // Punctuation (Common US layout mappings)
Â  Â  Â  Â  {"Semicolon", VK_OEM_1}, 
Â  Â  Â  Â  {"Equal", VK_OEM_PLUS}, 
Â  Â  Â  Â  {"Comma", VK_OEM_COMMA}, 
Â  Â  Â  Â  {"Minus", VK_OEM_MINUS}, 
Â  Â  Â  Â  {"Period", VK_OEM_PERIOD}, 
Â  Â  Â  Â  {"Slash", VK_OEM_2}, 
Â  Â  Â  Â  {"Backquote", VK_OEM_3}, 
Â  Â  Â  Â  {"BracketLeft", VK_OEM_4}, 
Â  Â  Â  Â  {"Backslash", VK_OEM_5}, 
Â  Â  Â  Â  {"BracketRight", VK_OEM_6}, 
Â  Â  Â  Â  {"Quote", VK_OEM_7}, 
        {"NumpadEnter", VK_RETURN} // Numpad Enter often sends the same code as main Enter
Â  Â  };

Â  Â  auto it = keyMap.find(jsCode);
Â  Â  if (it != keyMap.end()) {
Â  Â  Â  Â  return it->second;
Â  Â  }
Â  Â  return 0; // Default or unknown key
}

void apply_control_input(const std::string& json_payload) {
Â  Â  try {
Â  Â  Â  Â  json j = json::parse(json_payload);
Â  Â  Â  Â  auto event = j["event"];
Â  Â  Â  Â  std::string eventType = event["type"].get<std::string>();

Â  Â  Â  Â  // std::cout << "-> Received control: " << eventType << std::endl;

Â  Â  Â  Â  INPUT input = {0};

Â  Â  Â  Â  if (eventType == "mousemove" || eventType == "mousedown" || eventType == "mouseup") {
Â  Â  Â  Â  Â  Â  int x = event["x"].get<int>();
Â  Â  Â  Â  Â  Â  int y = event["y"].get<int>();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // SCALING: Convert viewer's virtual 1920x1080 coordinates to Windows' 65535 absolute range
Â  Â  Â  Â  Â  Â  long scaledX = (long)((double)x * 65535.0 / (double)VIEWER_VIRTUAL_WIDTH);
Â  Â  Â  Â  Â  Â  long scaledY = (long)((double)y * 65535.0 / (double)VIEWER_VIRTUAL_HEIGHT);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 1. Move cursor first
Â  Â  Â  Â  Â  Â  input.type = INPUT_MOUSE;
Â  Â  Â  Â  Â  Â  input.mi.dwFlags = MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE;
Â  Â  Â  Â  Â  Â  input.mi.dx = scaledX;
Â  Â  Â  Â  Â  Â  input.mi.dy = scaledY;
Â  Â  Â  Â  Â  Â  SendInput(1, &input, sizeof(INPUT));

Â  Â  Â  Â  Â  Â  // 2. Handle click/release (only for mousedown/mouseup)
Â  Â  Â  Â  Â  Â  if (eventType == "mousedown" || eventType == "mouseup") {
Â  Â  Â  Â  Â  Â  Â  Â  int button = event["button"].get<int>(); // 0=Left, 2=Right
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  input.mi.dwFlags = 0; 
Â  Â  Â  Â  Â  Â  Â  Â  if (button == 0) { // Left Click
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  input.mi.dwFlags = (eventType == "mousedown" ? MOUSEEVENTF_LEFTDOWN : MOUSEEVENTF_LEFTUP);
Â  Â  Â  Â  Â  Â  Â  Â  } else if (button == 2) { // Right Click
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  input.mi.dwFlags = (eventType == "mousedown" ? MOUSEEVENTF_RIGHTDOWN : MOUSEEVENTF_RIGHTUP);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  SendInput(1, &input, sizeof(INPUT));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (eventType == "keydown" || eventType == "keyup") {
Â  Â  Â  Â  Â  Â  std::string keyCode = event["code"].get<std::string>();
Â  Â  Â  Â  Â  Â  UCHAR vkCode = map_js_code_to_vk(keyCode); 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (vkCode != 0) {
Â  Â  Â  Â  Â  Â  Â  Â  input.type = INPUT_KEYBOARD;
Â  Â  Â  Â  Â  Â  Â  Â  input.ki.wVk = vkCode;
Â  Â  Â  Â  Â  Â  Â  Â  input.ki.dwFlags = (eventType == "keyup" ? KEYEVENTF_KEYUP : 0);
Â  Â  Â  Â  Â  Â  Â  Â  SendInput(1, &input, sizeof(INPUT));
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  std::cout << "Warning: Unmapped key code received: " << keyCode << std::endl;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  } catch (const json::exception& e) {
Â  Â  Â  Â  std::cerr << "JSON Parsing error in control input: " << e.what() << std::endl;
Â  Â  } catch (const std::exception& e) {
Â  Â  Â  Â  std::cerr << "Control application error: " << e.what() << std::endl;
Â  Â  }
}

// WS Receive Loop - Dynamic ID and Control Handling
void websocket_receive_loop() {
Â  Â  char buffer[4096];
Â  Â  while (isConnected) {
Â  Â  Â  Â  // Reset buffer before receiving
Â  Â  Â  Â  ZeroMemory(buffer, sizeof(buffer));
Â  Â  Â  Â  int bytesReceived = recv(sockGlobal, buffer, sizeof(buffer), 0);
Â  Â  Â  Â  
Â  Â  Â  Â  if (bytesReceived <= 0) {
Â  Â  Â  Â  Â  Â  std::cout << "âŒ Disconnected from server or error occurred\n";
Â  Â  Â  Â  Â  Â  isConnected = false;
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }

Â  Â  Â  Â  std::string received_data(buffer, bytesReceived);
Â  Â  Â  Â  
Â  Â  Â  Â  // ----------------------------------------------------
Â  Â  Â  Â  // PING/PONG: Handle Socket.IO PING (type '2') 
Â  Â  Â  Â  // ----------------------------------------------------
Â  Â  Â  Â  if (received_data.length() >= 1 && received_data[0] == '2') {
Â  Â  Â  Â  Â  Â  send(sockGlobal, "3", 1, 0); 
Â  Â  Â  Â  Â  Â  // std::cout << "ðŸ“ Sent PONG response\n";
Â  Â  Â  Â  Â  Â  continue; 
Â  Â  Â  Â  }

Â  Â  Â  Â  // ----------------------------------------------------
Â  Â  Â  Â  // DYNAMIC TARGET ID: Handle 'start-sharing' event from server
Â  Â  Â  Â  // ----------------------------------------------------
Â  Â  Â  Â  size_t startSharingPos = received_data.find("42[\"start-sharing\"");
Â  Â  Â  Â  if (startSharingPos != std::string::npos) {
Â  Â  Â  Â  Â  Â  size_t startPayload = received_data.find('{', startSharingPos);
Â  Â  Â  Â  Â  Â  size_t endPayload = received_data.find_last_of('}', bytesReceived); 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (startPayload != std::string::npos && endPayload != std::string::npos) {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  std::string json_payload = received_data.substr(startPayload, endPayload - startPayload + 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  json j = json::parse(json_payload);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetViewerId = j["targetId"].get<std::string>();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  std::cout << "ðŸŽ¯ Target Viewer set: " << targetViewerId << " (Screen sending will start)\n";
Â  Â  Â  Â  Â  Â  Â  Â  } catch (const json::exception& e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  std::cerr << "JSON Parsing error for start-sharing: " << e.what() << std::endl;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  // ----------------------------------------------------
Â  Â  Â  Â  // CONTROL INPUT: Handle 'receive-control-input' event
Â  Â  Â  Â  // ----------------------------------------------------
Â  Â  Â  Â  size_t eventPos = received_data.find("42[\"receive-control-input\"");
Â  Â  Â  Â  if (eventPos != std::string::npos) {
Â  Â  Â  Â  Â  Â  size_t startPayload = received_data.find('{', eventPos);
Â  Â  Â  Â  Â  Â  size_t endPayload = received_data.find_last_of('}', bytesReceived); 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (startPayload != std::string::npos && endPayload != std::string::npos && startPayload < endPayload) {
Â  Â  Â  Â  Â  Â  Â  Â  std::string json_payload = received_data.substr(startPayload, endPayload - startPayload + 1);
Â  Â  Â  Â  Â  Â  Â  Â  apply_control_input(json_payload);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  std::cout << "Warning: Could not extract full JSON payload for control input.\n";
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
    closesocket(sockGlobal);
    WSACleanup();
}

// ================= MAIN THREADS =================
void screen_capture_and_send_loop() {
Â  Â  // Wait a moment after connection to ensure handshake is complete
Â  Â  std::this_thread::sleep_for(std::chrono::milliseconds(500)); 
Â  Â  
Â  Â  send_online_signal(); // Send the dynamic ID to register the Sharer

Â  Â  while (isConnected) {
Â  Â  Â  Â  // Only send screen updates if the Target Viewer ID is set
Â  Â  Â  Â  if (!targetViewerId.empty()) { 
Â  Â  Â  Â  Â  Â  std::vector<unsigned char> jpg;
Â  Â  Â  Â  Â  Â  capture_screen(jpg);
Â  Â  Â  Â  Â  Â  std::string base64_str = base64_encode(jpg.data(), jpg.size());
Â  Â  Â  Â  Â  Â  send_screen_update(base64_str);
Â  Â  Â  Â  }
Â  Â  Â  Â  // Adjust this for desired FPS (80ms is approx 12.5 FPS)
Â  Â  Â  Â  std::this_thread::sleep_for(std::chrono::milliseconds(80)); 
Â  Â  }
}


// ================= MAIN FUNCTION =================

int main(int argc, char* argv[]) {
Â  Â  // 1. Dynamic ID extraction from Command Line Argument (URL)
Â  Â  if (argc > 1) {
Â  Â  Â  Â  agentUserId = get_user_id_from_url(argv[1]);
Â  Â  }

Â  Â  if (agentUserId.empty()) {
Â  Â  Â  Â  std::cerr << "âŒ Error: Could not determine AGENT_USER_ID from command line.\n";
Â  Â  Â  Â  std::cerr << "Please ensure agent.exe is run via the browser's download link (with ?user_id=...). Exiting.\n";
Â  Â  Â  Â  return 1;
Â  Â  }
Â  Â  
Â  Â  std::cout << "Starting C++ Agent for User: " << agentUserId << "...\n";
Â  Â  
Â  Â  // Initialize GDI+
Â  Â  GdiplusStartupInput gpsi;
Â  Â  ULONG_PTR token;
Â  Â  GdiplusStartup(&token, &gpsi, NULL);
Â  Â  init_jpeg();

Â  Â  if (!websocket_connect()) {
Â  Â  Â  Â  GdiplusShutdown(token);
Â  Â  Â  Â  return 0;
Â  Â  }

Â  Â  // Start threads for receiving commands and sending screen
Â  Â  std::thread receive_thread(websocket_receive_loop);
Â  Â  std::thread send_thread(screen_capture_and_send_loop);
Â  Â  
Â  Â  // Wait for threads to finish
Â  Â  receive_thread.join();
Â  Â  send_thread.join();
Â  Â  
Â  Â  GdiplusShutdown(token);
Â  Â  return 0;
}